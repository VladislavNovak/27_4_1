<details open>
<summary><span style="color:tomato;font-size:16px">Class</span></summary>
<details open>
<summary><span style="color:tomato;font-size:12px">Задача: Реализация деревни эльфов</span></summary>

Лесные эльфы расположили свою деревню в лесу, прямо на деревьях. 
Нужно расселить эльфов по веткам деревьев, а затем подсчитать общее количество соседей определённого эльфа.

Всего в лесу пять деревьев, каждое из которых генерируется с помощью случайных чисел, 
заданных в указанных далее диапазонах. 
На каждом дереве есть 3–5 основных больших ветвей. 
На каждой большой ветке расположены ещё 2-3 средние ветки. 
Дома эльфов построены на больших и на средних ветках. 
Более мелкие ветви не рассматриваются в этой задаче.

В начале программы пользователь размещает в каждом доме по одному эльфу. 
Делается это с помощью последовательного перебора всех имеющихся домов и 
запроса имени заселяемого эльфа через стандартный ввод. 
Если было введено None в качестве имени, то дом пропускается и не заселяется никем.

После этого требуется найти определённого эльфа по имени. 
Имя искомого эльфа вводится через стандартный ввод. 
Для найденного эльфа нужно вывести общее количество эльфов, живущих вместе с ним на одной большой ветви. 
Это и будет искомое количество соседей.

</details>

<details open>
<summary><span style="color:tomato;font-size:12px">Краткое описание и термины:</span></summary>


<details open>
<summary><span style="color:tomato;font-size:12px">Классы Node и Tree</span></summary>

`Node` - это базовая единица, которая содержит id, name, parent, children, stage:

`id` - нужен для позиционирования узлов друг относительно друга в одном tree.
Уникально в рамках ОДНОГО tree.

`name` - содержит имя. В контексте задания, под name можно подразумевать эльфа.
Может быть или "None", или уникальным для ВСЕХ деревьев.

`parent` - указатель на родительский объект (нужно для позиционирования в tree)

`children` - массив дочерних объектов (нужно для позиционирования в tree)

`stage` - содержит инфо о расположении в tree относительно корня.
Нужно пока лишь для правильного вывода дерева в консоль

`Tree` - содержит информацию о всех вложенных Node (узлах).
При инициализации автоматически создается корень Node с id == 0.
Все последующие узлы добавляются либо с помощью метода createNode, либо generateNode.

`createNode` - ручное добавление узла. Здесь выбирается имя для нового узла и id его родителя.

`generateNode` - аналогичен createNode с той разницей, что создаёт узел посредством случайного набора данных

Помимо этого Tree содержит ряд полезных методов:

`changeName` - позволяет заменить имя указанного узла

`findNeighbors` - по указанному имени найти соседние узлы. Т.е. узлы, у которых одни родитель

`printTree` - распечатывает всё дерево. Т.е. все узлы от корня

Во внутренней реализации интересны функции `getNodeByName` и `getNodeById`,
которые, рекурсивно итерируясь по дереву, позволяют находить узел или по имени, или по id

</details>

<details open>
<summary><span style="color:tomato;font-size:12px">Массив Trees и ход выполнения программы</span></summary>

Может быть несколько деревьев (vector<Tree*>)
Каждое дерево обладает набором узлов с уникальными id в рамках конкретного tree.
Однако, по заданию, имя (эльфа) должно быть уникальным.
Соседние деревья ничего не "знают" о своих соседях.
Поэтому, список имён вынесен ИЗ каждого дерева в отдельный массив (namesCollection),
внешний по отношению к массиву trees. Поэтому создан механизм:

при создании узла (createNode, generateNode), новое имя, если было добавлено (и не равно "None"),
помещается в namesCollection.
Если же имя узла изменялось в процессе работы (changeName), то старое имя из него ещё и удаляется.
В итоге, всё это позволяет анализируя namesCollection, своевременно отсекать неверно введенные имена,
далее: итерироваться по всем деревьям, осуществляя поиск по имени (findNeighbors).
И, если оно найдено, моментально прекращать дальнейший поиск.

Меню содержит возможность: 

* добавить новый узел к выбранному дереву
* распечатать конкретное дерево
* распечатать все деревья
* заменить имя у выбранного узла конкретного дерева
* найти узел по имени и распечатать его соседей
* посмотреть имена всех узлов всех деревьев (кроме "None"). Каждое имя уникально и нельзя ввести несколько одинаковых
* выйти из программы. Все объекты (node и tree) созданы с выделением памяти в куче. При выходи отрабатывают деструкторы

</details>

</details>

<details>
<summary><span style="color:tomato;font-size:12px">Полезные ссылки</span></summary>

<p><a href="https://www.geeksforgeeks.org/deleting-a-binary-tree-using-the-delete-keyword/" style="margin-left:16px">Deleting a binary tree using the delete keyword</a></p>
<p><a href="https://proproprogs.ru/structure_data/std-dvusvyaznyy-spisok-list-v-stl-na-c" style="margin-left:16px">Двусвязный список (list) в STL на С++</a></p>
<p><a href="https://habr.com/ru/sandbox/153128/" style="margin-left:16px">Реализация односвязного списка на c++</a></p>
<p><a href="https://prog-cpp.ru/data-tree/" style="margin-left:16px">Дерево</a></p>



</details>
</details>